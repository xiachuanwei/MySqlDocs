##### 1. MySql基础架构：
按照查询过程来讲，主要包含以下组件：
1. 连接器：身份和权限相关
  * 连接器会保存权限相关信息，所以更改权限需要重新建立连接才能生效，或者执行 mysqladmin flush-privileges；
  * MySql在执行过程中使用的内存是属于连接对象，断开后才会释放，所以长连接累积下来会导致内存占用太大，所以考虑定期断开重连；
2. 查询缓存：缓存查询结果，执行查询语句时，先查询缓存
  * 大部分情况弊大于利，且应用端目前有更多更好的缓存方案，8.0已经移除此部分
  * queryCache的缓存key是hash值，所以任何不同(空格、大小写等)都会导致cache不可用
  * query_cache_type有三个值，OFF/ON/DEMAND,最好按需配置使用DEMAND
  * 只要有一个表更新，涉及到这个表的所有缓存全部失效
  * 查询中如果含有now()之类的函数，不会被缓存
  * 查询缓存对读写都会造成额外性能消耗：读取时需要将缓存存入查询缓存，写入时需要将该表对应的所有缓存都设置为失效即删除缓存内容
  * 如果查询缓存使用了很大的内存，缓存失效可能会成为问题瓶颈，因为缓存失效操作会持有一个全局锁，检测是否命中缓存以及缓存失效检测都需要等待这个锁
3. 分析器：词法分析-语法分析（解析器和预处理器）
  * 词法分析：提取出关键字，比如查询的表、列、查询条件等
  * 语法分析：判断sql是否正确，符合mysql语法
  * 解析器：将sql解析为一个语法树，校验关键字及顺序等是否正确
  * 预处理器会进一步检查解析树是否合法，比如数据表列是否存在，名字和别名等
4. 优化器： 优化查询，按照最优方案执行，比如多个索引时使用哪个索引，多表join时表连接顺序；
5. 执行器： 执行语句，执行器会先校验权限，若有权限则调用引擎的接口返回数据  

从层级结构来讲主要分为Server层和存储引擎层
1. Server层：包含连接器至执行器，所有跨存储引擎的功能都在这一层实现，比如存储过程、出发前、视图和函数等，以及通用日志模块binlog日志；
2. 存储引擎：负责数据的存储和读取，可替换式的架构，支持InnoDb、MyISAM等，其中最常用的是innodb。
#### 2. 一条查询SQL语句执行顺序
一条SQL语句执行顺序为：权限校验—>查询缓存—>分析器—>优化器—>权限校验—>执行器—>引擎
#### 3. InnoDB引擎redo log日志
1. redolog与binlog区别
 * binlog记录MySQL数据库相关的日志记录，包括InnoDB，MyISAM等其它存储引擎的日志；而redolog只记录InnoDB存储引擎本身的事务日志。
 * binlog记录事务的具体操作内容，格式为statment/row/mixed，是逻辑日志；而redolog记录每个页的更改的物理情况，是物理日志。
 * binlog只在事务提交完成后进行写入，只写磁盘一次，不论这时事务量多大；而redolog在事务进行中，就不断有重做日志条目(redo entry)写入重做日志文件。
2. 为什么需要redolog  
 MySql更新数据的时候不是按照条而是按照页更新，IO成本太高；而redolog使用的WAL技术（Write-Ahead-Logging），关键点就是先写日志再写磁盘，当有更新时先将更新写入redolog，然后再写入磁盘，大大降低了IO成本
3. binlog为什么不能crash-safe  
假如只有binlog，有可能先提交事务再写binlog，有可能事务提交数据更新之后数据库崩了，还没来得及写binlog。我们都知道binlog一般用来做数据库的主从复制或恢复数据库，这样就导致主从数据库不一致或者无法恢复数据库了。同样即使先写binlog再提交事务更新数据库，还是有可能写binlog成功之后数据库崩掉而导致数据库更新失败，这样也会导致主从数据库不一致或者无法恢复数据库。所以只有binlog做不到crash-safe。
4. redolog如何保证crash-safe    
为了支持crash-safe，需要redolog，而且为了保证逻辑一致，事务提交需要两个阶段：prepare阶段和commit阶段。1.写redolog并落入磁盘(prepare)-->2.写binlog-->3.commit。  
当在2之前崩溃时：重启恢复发现没有commit且没有binlog，回滚；备份恢复没有binlog，log一致。
当在3之前崩溃时：重启恢复发现没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份恢复有binlog. log一致。
5. redo-log-buffer与redolog file  
redo日志缓冲是InnoDB存储引擎的内存区域中的一部分，配置策略时最好配置为每个事务提交时会将重做日志缓冲刷新到重做日志文件
#### 4. 一条更新SQL语句执行顺序  
1. 类似查询，将更新的记录从磁盘读到内存中，并返回给执行器；
2. 执行器拿到引擎给的行数据，对数据进行改变，调用引擎接口将新的行数据写入，即传给引擎
3. 引擎将新数据更新至内存中，同时将该更新操作记录至redolog并落盘，状态为prepare，然后告诉执行器完成了，随时可以提交事务
4. 执行器生成该操作的binlog，并把binlog写入磁盘
5. 执行器调用引擎的提交事务接口，把刚刚的redolog状态更新为commit，更新完成